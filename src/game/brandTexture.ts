import * as THREE from 'three';

interface ApplyLogoOptions {
  scale?: number;
  position?: { x: number; y: number };
  rotation?: number;
  opacity?: number;
}

/**
 * Composites a logo onto a base texture using a 2D canvas and returns a new THREE.CanvasTexture.
 *
 * @param baseTexture The original texture (e.g., of the jersey).
 * @param logoImage The user-uploaded logo image.
 * @param options Transformation options for the logo.
 * @returns A promise that resolves with the new THREE.CanvasTexture.
 */
export async function applyLogoToTexture(
  baseTexture: THREE.Texture,
  logoImage: HTMLImageElement,
  options: ApplyLogoOptions = {}
): Promise<THREE.CanvasTexture> {
  const {
    scale = 1,
    position = { x: 0.5, y: 0.5 }, // Default to center
    rotation = 0,
    opacity = 1
  } = options;

  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  if (!ctx) {
    throw new Error('Failed to get 2D context from canvas');
  }

  const baseImage = baseTexture.image as HTMLImageElement;

  // Set canvas size to match the base texture
  canvas.width = baseImage.width;
  canvas.height = baseImage.height;

  // 1. Draw the base texture
  ctx.drawImage(baseImage, 0, 0);

  // 2. Prepare transformations for the logo
  ctx.save();
  ctx.globalAlpha = opacity;

  // Translate to the target position to make rotation and scaling origin-centric
  const targetX = canvas.width * position.x;
  const targetY = canvas.height * position.y;
  ctx.translate(targetX, targetY);
  ctx.rotate(rotation * (Math.PI / 180));

  const logoWidth = logoImage.width * scale;
  const logoHeight = logoImage.height * scale;

  // Draw the logo centered on the new origin
  ctx.drawImage(logoImage, -logoWidth / 2, -logoHeight / 2, logoWidth, logoHeight);

  ctx.restore();

  // 3. Create a new Three.js texture from the canvas
  const newTexture = new THREE.CanvasTexture(canvas);
  newTexture.needsUpdate = true;
  newTexture.flipY = baseTexture.flipY; // Preserve original texture properties
  newTexture.colorSpace = baseTexture.colorSpace;

  // Important for performance and quality: generate mipmaps
  // The texture is ready, but mipmaps will be generated by the renderer on next use.

  return newTexture;
}

/**
 * Loads an image from a URL and returns an HTMLImageElement.
 * @param url The URL of the image to load.
 * @returns A promise that resolves with the loaded HTMLImageElement.
 */
export function loadImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'Anonymous'; // Handle CORS for images from other domains
    img.onload = () => resolve(img);
    img.onerror = (err) => reject(err);
    img.src = url;
  });
}
